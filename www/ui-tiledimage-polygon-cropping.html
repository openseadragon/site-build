<style>
    textarea {
        width: 330px;
        height: 200px;
        font-family: monospace;
    }
    .box-with-title {
        padding-top: 1em;
        display: inline-block;
        text-align: center;
    }
    .buttons {
        width: 215px;
        margin-bottom: 10px;
    }
    *:focus {
        outline: none;
    }
    .info-panel {
        padding: 15px;
        border-radius: 5px;
        margin-bottom: 20px;
        background: transparent;
    }
    pre {
        background: #f5f5f5;
        padding: 10px;
        border-radius: 3px;
        overflow-x: auto;
    }
    .btn {
        margin: 5px 0;
        padding: 8px 12px;
        cursor: pointer;
        background: #4285f4;
        color: white;
        border: none;
        border-radius: 4px;
        font-size: 14px;
    }
    .button-group {
        margin: 12px 0 3px 0;
        display: flex;
        gap: 10px;
        justify-content: center;
        flex-wrap: wrap;
    }
    .openseadragon {
        width: 100%;
        height: 500px;
        border: 1px solid #ddd;
        margin-bottom: 15px;
    }
    /* Overlay marker styling */
    .osd-point-dot {
        width: 12px;
        height: 12px;
        background: #d52b2b;
        border: 2px solid #fff;
        border-radius: 50%;
        box-shadow: 0 0 2px #000;
        pointer-events: none;
        position: absolute;
    }
    .osd-svg-polygon {
        pointer-events: none;
        position: absolute;
        z-index: 10;
    }
</style>

<!-- Load OpenSeadragon library (MUST come before your JS code) -->
<script src="https://openseadragon.github.io/openseadragon/openseadragon.min.js"></script>

<h2>Polygon Cropping for TiledImages</h2>

<div class="info-panel">
    <p>OpenSeadragon allows precise image cropping using polygon shapes. This feature is useful for:</p>
    <ul style="list-style-type: disc; margin-left: 20px;">
        <li>Highlighting specific regions of interest</li>
        <li>Creating non-rectangular image masks</li>
        <li>Interactive annotation tools</li>
    </ul>
    <p><strong>Coordinate Handling:</strong> Polygon points should be provided in <strong>image coordinates</strong> (original pixel dimensions). During rendering, OpenSeadragon converts these to viewport coordinates automatically.</p>
    <p>The feature takes an array of polygons to crop the TiledImage during draw tiles. The render function will use non-zero winding rule to create the polygons. You can use OpenSeadragon.Point or plain xy object.</p>
    <p>The draw tiles will convert the provided polygons into the correct position in the viewport. Thus, the polygon points are treated as image coordinates at 0 degree.</p>
</div>

<h3>Implementation Guide</h3>

<div>
    <h4>Polygon Format Requirements</h4>
    <p>Provide an array of polygons where each polygon is an array of <code>{x, y}</code> coordinate objects:</p>
    <pre>[
  [{x: 197, y: 172}, {x: 226, y: 172}, {x: 226, y: 198}],
  [{x: 328, y: 280}, {x: 338, y: 199}, {x: 332, y: 201}]
]</pre>
    <h4>Basic Implementation</h4>
    <pre>// Apply polygons to a TiledImage
viewer.addHandler('open', function() {
  const tiledImage = viewer.world.getItemAt(0);
  tiledImage.setCroppingPolygons(yourPolygonsArray);
});</pre>
</div>

<div class="demoarea">
    <div class="demoheading">
        Interactive Polygon Cropping Tool
    </div>
    <div id="contentDiv" class="openseadragon"></div>

    <div class="button-group">
        <button id='resetBtn' class="btn">Reset All</button>
        <button id='exampleBtn' class="btn">Load Example Polygons</button>
    </div>
    
    <div class='box-with-title'>
        <h4>Polygon Points</h4>
        <div class="button-group">
            <button id="addPointBtn" class="btn">Add Points as Polygon</button>
            <button id="clearPointsBtn" class="btn">Clear Points</button>
        </div>
        <textarea id="polygonPointEl" placeholder="Click on image to add points..."></textarea>
    </div>
    
    <div class='box-with-title'>
        <h4>Current Polygons</h4>
        <div class="button-group">
            <button id="cropBtn" class="btn">Apply Cropping</button>
            <button id="clearPolygonsBtn" class="btn">Clear Polygons</button>
        </div>
        <textarea id='previewEl' placeholder="Polygons will appear here..."></textarea>
    </div>
</div>

<script>
    // Use remote DZI image for reliability
    var viewer = OpenSeadragon({
        id: "contentDiv",
        prefixUrl: "/openseadragon/images/",
        tileSources: "https://openseadragon.github.io/example-images/highsmith/highsmith.dzi",
        showZoomControl: true,
        showHomeControl: true,
        showFullPageControl: true,
        gestureSettingsMouse: { clickToZoom: false }
    });

    const previewEl = document.getElementById('previewEl');
    const polygonPointEl = document.getElementById('polygonPointEl');

    // Original full example set, as in old version (restored)
    const examples = [
        // Library of Congress shape
        [
            { x: 2751.28, y: 5297.41 }, { x: 2766.79, y: 5297.41 }, { x: 4031.96, y: 5285.35 },
            { x: 4033.68, y: 5293.96 }, { x: 4069.88, y: 5307.75 }, { x: 4061.26, y: 5404.28 },
            { x: 3406.27, y: 5406 }, { x: 2773.69, y: 5407.72 }
        ],
        // Left triangle
        [
            { x: 1571.28, y: 8401.91 }, { x: 1807.08, y: 7972.51 }, { x: 2355.62, y: 7972.51 }
        ],
        // Right triangle
        [
            { x: 5100.79, y: 8384.53 }, { x: 4932.01, y: 7962.58 }, { x: 4388.43, y: 7965.06 }
        ],
        // Center Rectangle
        [
            { x: 3214.41, y: 7766.50 }, { x: 3244.20, y: 7562.97 }, { x: 3559.42, y: 7562.97 }, { x: 3556.94, y: 7766.50 }
        ]
    ];

    let pointOverlayIds = [];

    function clearPointOverlays() {
        pointOverlayIds.forEach(id => {
            const el = document.getElementById(id);
            if (el) viewer.removeOverlay(el);
        });
        pointOverlayIds = [];
    }

    function addPointOverlay(viewportPt) {
        const marker = document.createElement('div');
        marker.className = 'osd-point-dot';
        const id = 'osd-dot-' + Math.random().toString(36).substr(2, 9);
        marker.id = id;
        marker.style.position = 'absolute';
        viewer.addOverlay({ element: marker, location: viewportPt });
        pointOverlayIds.push(id);
    }

    function drawPolygonOutlines(polygons) {
        const prevSvg = document.getElementById('main-svg-polygon');
        if (prevSvg) viewer.removeOverlay(prevSvg);

        if (!polygons || !polygons.length) return;

        const pList = polygons.map(poly =>
            poly.map(pt => viewer.viewport.imageToViewerElementCoordinates(pt.x, pt.y))
        );
        let allX = [], allY = [];
        pList.forEach(poly => poly.forEach(pt => { allX.push(pt.x); allY.push(pt.y); }));
        const minX = Math.min(...allX), minY = Math.min(...allY), maxX = Math.max(...allX), maxY = Math.max(...allY);
        const width = maxX - minX, height = maxY - minY;
        if (width === 0 || height === 0) return;

        let svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', width);
        svg.setAttribute('height', height);
        svg.setAttribute('class', 'osd-svg-polygon');
        svg.style.position = 'absolute';
        svg.id = 'main-svg-polygon';

        polygons.forEach((poly, i) => {
            let pts = pList[i].map(pt => (pt.x - minX) + ',' + (pt.y - minY)).join(' ');
            let polygonElem = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygonElem.setAttribute('points', pts);
            polygonElem.setAttribute('stroke', '#1976d2');
            polygonElem.setAttribute('stroke-width', '3');
            polygonElem.setAttribute('fill', 'rgba(30,114,255,0.20)');
            svg.appendChild(polygonElem);
        });

        viewer.addOverlay({
            element: svg,
            location: new OpenSeadragon.Rect(minX, minY, width, height),
            placement: OpenSeadragon.Placement.TOP_LEFT
        });
    }

    document.getElementById('clearPointsBtn').addEventListener('click', () => {
        polygonPointEl.value = '';
        clearPointOverlays();
    });

    document.getElementById('clearPolygonsBtn').addEventListener('click', () => {
        previewEl.value = '';
        viewer.world.getItemAt(0)?.resetCroppingPolygons();
        const prevSvg = document.getElementById('main-svg-polygon');
        if (prevSvg) viewer.removeOverlay(prevSvg);
    });

    document.getElementById('exampleBtn').addEventListener('click', () => {
        previewEl.value = JSON.stringify(examples, null, 2);
        const prevSvg = document.getElementById('main-svg-polygon');
        if (prevSvg) viewer.removeOverlay(prevSvg);
        drawPolygonOutlines(examples);
    });

    document.getElementById('addPointBtn').addEventListener('click', () => {
        try {
            const points = JSON.parse(polygonPointEl.value || '[]');
            if (points.length >= 3) {
                const currentPolygons = JSON.parse(previewEl.value || '[]');
                previewEl.value = JSON.stringify([...currentPolygons, points], null, 2);
                polygonPointEl.value = '';
                clearPointOverlays();
                drawPolygonOutlines([...currentPolygons, points]);
            } else {
                alert('A polygon requires at least 3 points');
            }
        } catch (e) {
            alert("Invalid format in points textarea.");
        }
    });

    document.getElementById('cropBtn').addEventListener('click', () => {
        try {
            const polygons = JSON.parse(previewEl.value || '[]');
            if (polygons.length > 0) {
                viewer.world.getItemAt(0)?.setCroppingPolygons(polygons);
                drawPolygonOutlines(polygons);
            }
        } catch (e) {
            alert('Error applying polygons: ' + e);
        }
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
        polygonPointEl.value = '';
        previewEl.value = '';
        viewer.world.getItemAt(0)?.resetCroppingPolygons();
        clearPointOverlays();
        const prevSvg = document.getElementById('main-svg-polygon');
        if (prevSvg) viewer.removeOverlay(prevSvg);
    });

    viewer.addHandler('canvas-click', function(event) {
        const viewportPoint = viewer.viewport.pointFromPixel(event.position);
        const imagePoint = viewer.viewport.viewportToImageCoordinates(viewportPoint);
        const point = {
            x: Math.round(imagePoint.x * 100) / 100,
            y: Math.round(imagePoint.y * 100) / 100
        };
        let pts = [];
        try { pts = JSON.parse(polygonPointEl.value || '[]'); } catch (e) {}
        polygonPointEl.value = JSON.stringify([...pts, point], null, 2);
        addPointOverlay(viewportPoint);
    });

    viewer.addHandler('open', function() {
        clearPointOverlays();
        const prevSvg = document.getElementById('main-svg-polygon');
        if (prevSvg) viewer.removeOverlay(prevSvg);
    });
</script>
